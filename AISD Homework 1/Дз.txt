--- 1
Дан массив A целых чисел длиной в n, а также дано число K. Задача: найти количество подмассивов, сумма элементов которых равна K. Для определения сложности будем использовать префиксные суммы. Разберем что это. Пусть у нас есть сумма (prefix[i] = A[0] + A[1] + ... + A[i]) - это сумма элементов от начала массива до i включительно. Допустим нам нужен подмассив [l + 1 ... r] с суммой K. Для начала определим (prefix[r] = A[0] + A[1] + ... + A[l] + A[l + 1] + ... + A[r]), где (prefix[l] = A[0] + A[1] + ... + A[l]). Получается сумма подмассива (K = prefix[r] - prefix[l]), переносим в другую сторону и получаем формулу (prefix[l] = prefix[r] - K). 

Когда мы находимся в позиции r и знаем текущую сумму prefix[r], нам нужно узнать, был ли раньше такой индекс l, у которого prefix[l] = prefix[r] - K, если да, то между l и r есть подмассив с суммой K. Возьмем например массив [1, 2, 3] и K = 3. При r = 1 (prefix[r] = 3, так как сумма prefix[0] + prefix[1] = 3), и затем находим prefix[l] = 3 - 3 = 0. Такой индекс есть, значит, подмассив [1, 2] имеет сумму K. И также с остальными. Сложность O(n), поскольку мы проходимся по массиву один раз, то есть если мы например сделаем массив вдвое больше, то удвоится и необходимое количество операций для выполнения алгоритма.




--- 2
Дан массив целых чисел arr. Нужно найти длину самого длинного непрерывного подмассива, в котором все элементы уникальны. Например если взять массив [1, 2, 1, 3, 4, 2, 3], то самый длинный уникальный подмассив это [1, 3, 4, 2]. Работать это все будет так, что существуют левая и правая границы и словарь где будет находиться индекс, когда элемент встречался последний раз. Код работает так, что если мы встречаем уникальный элемент, то двигаем правую границу вправо, однако если попадается уже встречавшийся элемент и он находится внутри границ, то мы двигаем левую границу вправо, чтобы убрать старое повторение. Затем обновляем последний индекс и считаем длину. Сложность O(n), так как right идет от 0 до n - 1 шагов, аналогично и left. 

 